<?php

class PassHash {

    /**
     * @var type String
     * developers targeting only PHP 5.3.7 and later should use "$2y$"
     *  in preference to "$2a$".
     * 
     * In June 2011, a bug was discovered in crypt_blowfish, a PHP implementation of BCrypt. It was mis-handling characters with the 8th bit set.[14] They suggested that system administrators update their existing password database, replacing $2a$ with $2x$, to indicate that those hashes are bad (and need to use the old broken algorithm). They also suggested the idea of having crypt_blowfish emit $2y$ for hashes generated by the fixed algorithm.
     */
    private static $algo = '$2y';
    
    // cost parameter
    private static $cost = '$10';
    
    
    /**
     * In cryptography, a salt is random data that is used as an additional
     *  input to a one-way function that "hashes" data, a password or
     *  passphrase. Salts are closely related to the concept of nonce.
     * 
     * Said another way - the random "salt" is stored with the hashed password,
     * then when the user logs in, a function calculates 
     * 
     * function($hash, $passwordEntered);
     * 
     * A boolean would return if $hash == $newHashCalculated
     * 
     */
    public static function unique_salt() {
        return substr(sha1(mt_rand()), 0, 22);
    }
    
    
    /**
     * Used to generate a hash - one-way string hashing
     */
   public static function hash($password) {
       return crypt($password, self::$algo . 
               self::$cost . 
               '$' . 
               self::unique_salt());
   }
    
   
   /**
    * Used to compare password entered with a hash - I still have questions
    * as to why this method of storing passwords works.  It must be that the 
    * hash produced by the crypt method is just too difficult to decrypt...
    * @param String $password_hash - originally stored hashed password
    * @param String $password
    * @return boolean - Hashed password equals new hashed password?
    */
    public static function check_password($password_hash, $password) {
        $full_salt = substr($password_hash, 0, 29);
        $new_hash = crypt($password, $full_salt);
        return ($password_hash == $new_hash);
    }
}


?>
